# 이분 탐색

# **문제**

이분 탐색(Binary search)는 정렬된 배열에서 원하는 원소를 찾는 탐색 알고리즘이다. 이분 탐색은 주어진 구간을 절반으로 나눠가면서 원하는 값의 위치를 찾을 수 있다.

길이가 `N` 인 정렬된 배열 `A` 에서 정수 `X` 보다 크거나 같은 원소가 처음으로 등장하는 위치를 이분 탐색으로 구해보자. 이분 탐색을 구현하는 방법은 다양하지만 이 문제에서는 아래와 같은 알고리즘을 통해서 구현해보자.

1. 변수 `lo` 와 `hi` 를 정의하고 `lo = -1` , `hi = N` 로 초기화한다.
    
    배열의 인덱스는 `0` 부터 `N - 1` 까지이지만, `A[-1] = -∞` 이고 `A[N] = ∞` 라고 가정하고 진행한다.
    
2. `mid = (lo + hi) / 2` , `A[mid]` 를 `X` 와 비교한다.
3. `A[mid] < X` 라면 `lo = mid`
4. `X ≤ A[mid]` 라면 `hi = mid`
5. `lo` 와 `hi` 가 인접할 때까지 이 과정을 반복한다.

```python
# A[lo] < X and X <= A[hi]
lo, hi = -1, N

while lo + 1 < hi:
    mid = (lo + hi) // 2

    if A[mid] < X:
        lo = mid
    else:
        hi = mid
```

위 알고리즘이 끝나면 `A[hi]` 가 우리가 찾으려는 원소가 된다. 그런데 만약 `A[N - 1]` 이 `X` 보다 작다면 배열에는 우리가 찾으려는 원소가 없기 때문에 `hi = N` 이 되는 것에 유의해야한다.

위 알고리즘으로 이분 탐색을 구현했을 때, `lo` 와 `hi` 가 어떻게 변하는지 과정을 구해보자.

# **입력**

첫째 줄에 정수 `N, X (1 ≤ N, X ≤ 100)`가 주어진다.

둘째 줄에 정수 `A[0], A[1], ..., A[N - 1] (0 ≤ A[i] ≤ 100)` 이 주어진다. 배열 `A` 는 오름차순으로 정렬되어 있다.

# **출력**

각각의 줄에 현재 탐색하는 범위의 시작과 끝을 출력한다. 탐색이 끝난 후에는 `hi` 를 출력한다.

# **예제 입력 1**

```python
8 4
0 1 2 3 4 5 6 7
```

# **예제 출력 1**

```python
1 8
3 8
3 5
4
```

# **예제 입력 2**

```python
4 5
0 1 2 3
```

# **예제 출력 2**

```python
1 4
1 4
2 4
4
```

`X > A[N - 1]` 이기 때문에, 주어진 배열 `A` 에서 `X` 보다 크거나 같은 원소는 등장하지 않는다.

# **예제 입력 3**

```python
3 1
2 4 5
```

# **예제 출력 3**

```python
1 3
-1 1
0
```

# **예제 입력 4**

```python
1 3
2
```

# **예제 출력 4**

```python
1 1
1
```

# **예제 입력 5**

```python
1 2
3
```

# **예제 출력 5**

```python
1 1
0
```
